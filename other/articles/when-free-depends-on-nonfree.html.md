When a program is free software (free as in freedom), that means it gives users the four freedoms, so that they control what the program does. In most cases, that is sufficient for the program's distribution to be ethical; but not always. There are additional problems that can arise in specific circumstances. This article describes a subtle problem, where upgrading the free program requires using a nonfree program. If the free program's use depends unavoidably on another program which is nonfree, we say that the free program is “trapped.” Its code is free software, and you may be able to copy pieces of its code into other free programs with good, ethical results. But you shouldn't run the trapped program, because that entails surrendering your freedom to the other nonfree program. Someone who upholds the principles of free software would not knowingly make a program that is trapped. However, many free programs are developed by people or companies that don't particularly support these principles, or don't understand the problem. Dependence on a nonfree program can take various forms. The most basic form is when the programming language used has no free implementation. The first programs I wrote for the GNU system in the 1980s, including GNU Emacs, GDB and GNU Make, had to be compiled with AT&T's nonfree C compiler, because there was no free C compiler until I wrote GCC. Fortunately, this kind of problem is mostly a thing of the past; we now have free compilers and platforms for just about all the languages anyone uses for writing free software. We can release the program from this kind of trap by translating it to another language, or by releasing a free implementation of the language it's written in. Thus, when a full free Java implementation became available, that released all the free Java programs from the Java Trap. This kind of dependence is conceptually simple because it stems from the situation at one given instant in time. At time T, free program P won't run without nonfree programming platform Q. To borrow a term from linguistics, this relationship is “synchronic.” More recently, we have seen another kind of dependence in database programs, where you can build and run any given version of the program in the free world, but upgrading from version N to version N+1 requires a nonfree program. This happens because the internal format of the database changes from version N to version N+1. If you have been seriously using version N, you probably have a large existing database in the version N format. To upgrade to version N+1 of the database software, you need to reformat that database. If the way you are supposed to do this is by running a proprietary database reformat program, or using the developer's service which is SaaSS (Service as a Software Substitute), the database software is trapped—but in a more subtle way. Any single version of the database program can be used without nonfree software or SaaSS. The problem arises when you try to keep using the program for the long term, which entails upgrading it from time to time; you can't use it this way without some nonfree software or equivalent. This database program is trapped across time—we could call it “diachronically trapped,” borrowing another term from linguistics. For example, the program OpenERP (since renamed “Odoo”), though free, is diachronically trapped. GNU Health, our free package for running a medical clinic, initially used OpenERP. In 2011, GNU Health developer Luis Falcón discovered that upgrading to the next version of OpenERP required sending the database (full of patients' medical data) to OpenERP's server for reformatting. This is SaaSS: it requires the user of GNU Health (a clinic) to entrust its own computing and its data to the company developer of OpenERP. Rather than bow down, Falcón rewrote GNU Health to use Tryton instead. Using SaaSS is inherently equivalent to running a proprietary program with snooping functionality and a universal back door. The service could keep a copy of the databases that users reformat. Even if we can trust the company that runs the service never to intentionally show any form of the data to anyone, we can't be sure that it won't be accessed by the intelligence agencies of various countries or security-breaking crackers (please don't call them “hackers”). When a program is diachronically trapped, releasing it from the trap requires more than a one-time job of programming. Rather, the job has to be done continually, each time there is a change in the data format. Launching a project with a long-term commitment to continue doing this is not easy. It may be easier to pressure the company to stop trying to trap users—by rejecting the trapped program until it does so. Given how difficult it is to free the program, you had better stay away from it. It is possible to try out a diachronically trapped free program without nonfree software, but if you're going to do more than dabble, you must steer clear of really using it. Both businesses and individuals will find fine free alternatives that don't have such a problem; all it takes to avoid the trap is to recognize it.